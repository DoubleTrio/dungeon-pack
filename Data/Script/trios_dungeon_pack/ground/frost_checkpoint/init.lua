--[[
    init.lua
    Created: 12/29/2025 03:24:02
    Description: Autogenerated script file for the map frost_checkpoint.
]] --
-- Commonly included lua functions and data
require 'origin.common'
require 'trios_dungeon_pack.menu.EnchantmentSelectionsMenu'
require 'trios_dungeon_pack.emberfrost.enchantments'
require 'origin.menu.InventorySelectMenu'
-- Package name
local frost_checkpoint = {}

-- --This function is called to move partner to a specific marker on loading a new map
-- function PartnerEssentials.InitializePartnerSpawn(dir, customPosition)
-- 	--Each map has an initial point where the partner spawns.
-- 	--Set the Partner Spawn variable to default to let the partner spawn there
-- 	--My nomenclature, to keep things consistent, is to just copy the player's spawn marker's name,
-- 	--add _Partner to the end for the partner's marker.
-- 	--You can specify the dir parameter for a custom direction to spawn as if you want.
-- 	--This function also assigns ground partner AI to the partner so they actually follow you.

-- 	if GAME:GetPlayerPartyCount() < 2 then return end --do nothing if party is only size 1

-- 	local partner = CH('Teammate1')
-- 	local player = CH('PLAYER')

-- 	--in case a custom position is ever needed
-- 	if customPosition ~= nil then
-- 		dir = dir or partner.Direction
-- 		GROUND:TeleportTo(partner, customPosition.X, customPosition.Y, dir)
-- 	--otherwise use the marker system
-- 	elseif SV.partner.Spawn ~= 'Default' then
-- 		local player = CH('PLAYER')
-- 		local marker = MRKR(SV.partner.Spawn)

-- 		--Failsafe. Sometimes the spawn variable isn't handled properly, and you get to a map with an invalid marker.
-- 		--If this happens, act as though the marker is 'Default'. I.e. do nothing.
-- 		--The bug this failsafe fixes sometimes happens in normal gameplay but typically doesn't cause any visible issues. This is more of an issue with debugging requiring a map reload depending on how you get to it.
-- 		if marker ~= nil then
-- 			dir = dir or marker.Direction or partner.Direction
-- 			GROUND:TeleportTo(partner, marker.Position.X, marker.Position.Y, dir)
-- 		else
-- 			print('partner position marker failsafe hit')
-- 		end
-- 	end	

-- 	AI:SetCharacterAI(partner, "origin.ai.ground_partner", CH('PLAYER'), partner.Position)
--     partner.CollisionDisabled = true
-- 	partner.InteractOrder = 1--if partner and another NPC overlap, the partner is deprioritized and won't be spoken to, the other npc will

-- end
-------------------------------
-- Map Callbacks
-------------------------------
---frost_checkpoint.Init(map)
-- Engine callback function
function frost_checkpoint.Init(map)
  COMMON.RespawnAllies()
  -- COMMON.RespawnAllies(true)
  GROUND:AddMapStatus("snow")
  
  -- local snow_status = RogueEssence.Dungeon.MapStatus("snow")
	
	-- snow_status:LoadFromData()
  -- snow_status.Emitter.Layer = DrawLayer.NoDraw
	-- -- if _DATA.CurrentReplay == nil then
  --   print(tostring(snow_status.Emitter.Layer))
	-- TASK:WaitTask(_GROUND:AddMapStatus(snow_status))


  local player = CH('PLAYER')
  local partner = CH('Teammate_1')
  -- PartnerEssentials.InitializePartnerSpawn()
end

-- if _DATA.CurrentReplay == nil then
-- 	TASK:WaitTask(end_sequence())
-- else

--     -Reimplementation of the basic CheckBossClearEvent.
-- --Call something different from LuaBeginBattleEvent or edit this accordingly if you want a different wincon for your map or special effects/anims on win.
-- function SINGLE_CHAR_SCRIPT.LuaCheckBossClearEvent(owner, ownerChar, context, args)

-- 	--Sequence that runs when map is over. Fade out, cut the music, etc.
-- 	function end_sequence()

-- 		--HALCYON ONLY CHANGE, the only change I've made to this from the original reimplementation:
-- 		--A small wait before calling the end sequence proper so we can see more of the "won" battlefield
-- 		GAME:WaitFrames(40)

-- 		_GAME:BGM("", true)

-- 		TASK:WaitTask(_GAME:FadeOut(false))

-- 		_DUNGEON:ResetTurns()

-- 		--restore all and remove all map status
-- 		local statuses_to_remove = {}
-- 		for i = 0, _ZONE.CurrentMap.Status.Keys.Count - 1, 1 do
-- 			statuses_to_remove[i] = _ZONE.CurrentMap.Status.Keys[i]
-- 		end

-- 		for i = 0, #statuses_to_remove - 1, 1 do
-- 			TASK:WaitTask(_DUNGEON:RemoveMapStatus(statuses_to_remove[i], false))
-- 		end

-- 		--heal everyone in the party
-- 		for i = 0, GAME:GetPlayerPartyCount() - 1, 1 do
-- 			_DATA.Save.ActiveTeam.Players[i]:FullRestore()
-- 		end

-- 		TASK:WaitTask(_GAME:EndSegment(RogueEssence.Data.GameProgress.ResultType.Cleared))

-- 	end

-- 	--For each enemy team, check each chara in that team. If any are still alive, then fail this check and return early.
-- 	for i = 0, _ZONE.CurrentMap.MapTeams.Count - 1, 1 do
-- 		local team = _ZONE.CurrentMap.MapTeams[i].Players
-- 		for j = 0, team.Count - 1, 1 do
-- 			--Break and return early if even one enemy is not dead.
-- 			if not team[j].Dead then return end
-- 		end
-- 	end

-- 	--Everyone's dead, clear the scene.
-- 	local checks = owner.StatusStates:GetWithDefault(luanet.ctype(MapCheckState))

-- 	--The call originally for this was to remove(this), which isn't in lua. So we need to find the LuaCheckBossClearEvent and remove that (remove ourself)
-- 	for i = 0, checks.CheckEvents.Count - 1, 1 do
-- 		if LUA_ENGINE:TypeOf(checks.CheckEvents[i]) == luanet.ctype(SingleCharScriptEvent) then
-- 			if checks.CheckEvents[i].Script == args.CustomClearEvent then
-- 				checks.CheckEvents:Remove(checks.CheckEvents[i])
-- 			end
-- 		end
-- 	end

-- 	if _DATA.CurrentReplay == nil then
-- 		TASK:WaitTask(end_sequence())
-- 	else
-- 		TASK:WaitTask(_GAME:EndSegment(RogueEssence.Data.GameProgress.ResultType.Cleared))
-- 	end

-- end

-- function SINGLE_CHAR_SCRIPT.ItemWishEvent(owner, ownerChar, context, args)
-- 	local chara = context.User
-- 	UI:ResetSpeaker()
-- 	DUNGEON:CharSetAction(chara, RogueEssence.Dungeon.CharAnimPose(chara.CharLoc, chara.CharDir, 0, -1))
-- 	local crystal_moment_status = RogueEssence.Dungeon.MapStatus("crystal_moment")
-- 	crystal_moment_status:LoadFromData()
-- 	if _DATA.CurrentReplay == nil then
-- 		TASK:WaitTask(_DUNGEON:AddMapStatus(crystal_moment_status))
-- 	end

-- 	_ZONE.CurrentMap.HideMinimap = true
-- 	local curr_song = RogueEssence.GameManager.Instance.Song
-- 	SOUND:StopBGM()
-- 	UI:WaitShowDialogue("...[pause=0]Time momentarily pauses.[pause=0] The world around you holds their breath, as the crystal shines brightly.")
-- 	UI:ChoiceMenuYesNo("Would you like to make a wish?", false)
-- 	UI:WaitForChoice()
-- 	local result = UI:ChoiceResult()
-- 	if result then
-- 		local slot = GAME:FindPlayerItem("wish_gem", true, true)
-- 		if slot:IsValid() then
-- 			local wish_choices = map(DUNGEON_WISH_TABLE, function(item) return item.Category end)
-- 			table.insert(wish_choices, "Don't know")
-- 			local end_choice = #wish_choices
-- 			UI:BeginChoiceMenu("What do you desire?", wish_choices, 1, end_choice)
-- 			UI:WaitForChoice()
-- 			choice = UI:ChoiceResult()
-- 			if choice ~= end_choice then
-- 				if slot.IsEquipped then
-- 					GAME:TakePlayerEquippedItem(slot.Slot)
-- 				else
-- 					GAME:TakePlayerBagItem(slot.Slot)
-- 				end
-- 				GAME:WaitFrames(50)
-- 				SOUND:PlayBattleSE("_UNK_EVT_044")
-- 				GAME:WaitFrames(10)
-- 				GAME:FadeOut(true, 40)
-- 				-- SOUND:PlayBattleSE("_UNK_EVT_091")
-- 				-- SOUND:PlayBattleSE("_UNK_EVT_096")
-- 				SOUND:PlayBattleSE("EVT_EP_Regi_Permission")
-- 				-- SOUND:PlayBattleSE("EVT_Dimenstional_Scream")
-- 				-- SOUND:PlayBattleSE("EVT_Fade_White")
-- 				-- SOUND:PlayBattleSE("EVT_Evolution_Start")
-- 				TASK:WaitTask(_DUNGEON:ProcessBattleFX(context.User, context.User, _DATA.SendHomeFX))
-- 				-- SOUND:PlayBattleSE("_UNK_EVT_074")
-- 				-- SOUND:PlayBattleSE("_UNK_EVT_084")
-- 							-- SOUND:PlayBattleSE("_UNK_EVT_087")
-- 				local emitter = RogueEssence.Content.SingleEmitter(RogueEssence.Content.AnimData("Last_Resort_Front", 4), 1)

-- 				-- local item_anim = RogueEssence.Content.ItemAnim(start_loc, end_loc, _DATA:GetItem(item).Sprite, RogueEssence.Content.GraphicsManager.TileSize / 2, 10)
-- 				emitter:SetupEmit(owner.TileLoc * RogueEssence.Content.GraphicsManager.TileSize + RogueElements.Loc(RogueEssence.Content.GraphicsManager.TileSize / 2), owner.TileLoc * RogueEssence.Content.GraphicsManager.TileSize + RogueElements.Loc(RogueEssence.Content.GraphicsManager.TileSize / 2), Direction.Left)
-- 				_DUNGEON:CreateAnim(emitter, DrawLayer.NoDraw)
-- 				GAME:FadeIn(60)
-- 				GAME:WaitFrames(80)

-- 				local item_table = DUNGEON_WISH_TABLE[choice]
-- 				local arguments = {}
-- 				arguments.MinAmount = item_table.Min
-- 				arguments.MaxAmount = item_table.Max
-- 				arguments.Guaranteed = item_table.Guaranteed
-- 				arguments.Items = item_table.Items
-- 				SINGLE_CHAR_SCRIPT.WishSpawnItemsEvent(owner, ownerChar, context, arguments)
-- 				GAME:WaitFrames(60)
-- 			end
-- 		else
-- 			UI:WaitShowDialogue("...[pause=0]" .. context.User:GetDisplayName(true) .. " cannot make a wish right now.")
-- 		end
-- 	end
-- 	-- GAME:WaitFrames(5)
-- 	UI:WaitShowDialogue("The crystal became dimmer.")

-- 	if _DATA.CurrentReplay == nil then
-- 		TASK:WaitTask(_DUNGEON:RemoveMapStatus("crystal_moment", false))
-- 		-- TASK:WaitTask(_DUNGEON:ProcessBattleFX(context.User, context.User, _DATA.SendHomeFX))
-- 	end
-- 	SOUND:PlayBGM(curr_song, true, 0)
-- 	GAME:WaitFrames(20)

-- 	_ZONE.CurrentMap.HideMinimap = false
-- 	GAME:WaitFrames(20)
-- 	local stand_anim =  RogueEssence.Dungeon.CharAnimNone(context.User.CharLoc, context.User.CharDir)
-- 	stand_anim.MajorAnim = true
-- 	TASK:WaitTask(context.User:StartAnim(stand_anim))
-- end

---frost_checkpoint.Enter(map)
-- Engine callback function
function frost_checkpoint.Enter(map)
  UI:WaitShowTitle("Frost Checkpoint - 1", 20)
  GAME:WaitFrames(60)
  UI:WaitHideTitle(20)
  GAME:FadeIn(20)
end

---frost_checkpoint.Exit(map)
-- Engine callback function
function frost_checkpoint.Exit(map)

end

---frost_checkpoint.Update(map)
-- Engine callback function
function frost_checkpoint.Update(map)

end

---frost_checkpoint.GameSave(map)
-- Engine callback function
function frost_checkpoint.GameSave(map)

end

---frost_checkpoint.GameLoad(map)
-- Engine callback function
function frost_checkpoint.GameLoad(map)
  GAME:FadeIn(20)
end

function frost_checkpoint.North_Exit_Touch(obj, activator)
  print("Touched North Exit")
end

function frost_checkpoint.South_Exit_Touch(obj, activator)
  print("Touched South Exit")
end

-- call this at the end of an npc conversation, sister function of above StartConversation function
local function EndConversation(target, changeNPCanimation)
  if changeNPCanimation == nil then
    changeNPCanimation = true
  end -- should NPC change their animation? useful for flying npcs too

  local hero = CH('PLAYER')
  -- local partner = CH('Teammate1')

  -- if target ~= partner then--if partner conversation was started don't turn them back around after
  if SV.TemporaryFlags.OldDirection ~= Direction.None then
    GROUND:EntTurn(target, SV.TemporaryFlags.OldDirection)
  end
  SV.TemporaryFlags.OldDirection = Direction.None -- Clear flag
  -- end

  -- GROUND:CharEndAnim(partner)
  GROUND:CharEndAnim(hero)
  -- if changeNPCanimation then GROUND:CharEndAnim(target) end

  -- partner.IsInteracting = false
end

-- local orig_settings = UI:ExportSpeakerSettings()
-- if fanfare then

-- end
-- UI:ResetSpeaker(false)
-- UI:SetCenter(true)
-- if not force_storage and GAME:GetPlayerBagCount() + GAME:GetPlayerEquippedCount() < GAME:GetPlayerBagLimit() then

function frost_checkpoint.Enchantment_Chest_Action(obj, activator)
  -- Check if the player directoin is facing the chest before opening...

  if (activator.Direction ~= Dir8.Up) then
    return
  end


  GROUND:CharSetAnim(activator, "None", true)


  local emitter = RogueEssence.Content.SingleEmitter(RogueEssence.Content.AnimData("Chest_Open", 10))
  -- emitter.LocHeight = 12
  GROUND:PlayVFX(emitter, obj.MapLoc.X + 18, obj.MapLoc.Y + 12)

  local emitter2 = RogueEssence.Content.SingleEmitter(RogueEssence.Content.AnimData("Chest_Light", 4))


  --   local startPos = obj.MapLoc * RogueEssence.Content.GraphicsManager.TileSize +
  --     RogueElements.Loc(RogueEssence.Content.GraphicsManager.TileSize / 2,
  --       RogueEssence.Content.GraphicsManager.TileSize / 2) + RogueElements.Loc(-100, 72)

  -- local endPos = obj.MapLoc * RogueEssence.Content.GraphicsManager.TileSize +
  --     RogueElements.Loc(RogueEssence.Content.GraphicsManager.TileSize / 2,
  --       RogueEssence.Content.GraphicsManager.TileSize / 2) + RogueElements.Loc(-80, 52)
  GROUND:PlayVFX(emitter2, obj.MapLoc.X - 100, obj.MapLoc.Y, Dir8.Left, -100, 100)


  GAME:WaitFrames(50)
  
  local crystal_moment_status = RogueEssence.Dungeon.MapStatus("crystal_moment")
	
	crystal_moment_status:LoadFromData()
  crystal_moment_status.Emitter.Layer = DrawLayer.Top

	_GROUND:AddMapStatus(crystal_moment_status)
  



  GAME:WaitFrames(60)



  local enchantments = { EmberfrostSatchel, Gain5000P, CalmTheStorm }


  -- title, enchantment_list, confirm_action, refuse_action, enchantment_width

  local ret = {}
  local choose = function(enchantment)
    ret = enchantment
    _MENU:RemoveMenu()
  end
  local refuse = function() _MENU:RemoveMenu() end



  local old = RogueEssence.Menu.MenuBase.BorderStyle

  print(tostring(old))
  RogueEssence.Menu.MenuBase.BorderStyle = 2
  print(RogueEssence.Menu.MenuBase.BorderStyle)


  local menu = EnchantmentSelectionMenu:new("Choose an enchantment!", enchantments, choose, refuse)
  UI:SetCustomMenu(menu.menu)
  UI:WaitForChoice()

  RogueEssence.Menu.MenuBase.BorderStyle = 


  _GROUND:RemoveMapStatus("crystal_moment")
  GAME:WaitFrames(30)
  -- TODO: Use the mission board as the template 


  -- local items = {
  --   { Item= "emberfrost_allterrain_gear", Amount = 1},
  --   { Item= "emberfrost_allterrain_gear", Amount = 1}
  -- }

  -- M_HELPERS.GiveInventoryItemsToPlayer(items)

  GROUND:CharEndAnim(activator)


  -- local emitter = SingleEmitter(AnimData("Chest_Light", 4))

  -- emitter:SetupEmit(
  --     obj.MapLoc * RogueEssence.Content.GraphicsManager.TileSize
  --         + RogueElements.Loc(
  --             RogueEssence.Content.GraphicsManager.TileSize / 2,
  --             RogueEssence.Content.GraphicsManager.TileSize / 2
  --         )
  --         + RogueElements.Loc(-100, 72),

  --     obj.MapLoc * RogueEssence.Content.GraphicsManager.TileSize
  --         + RogueElements.Loc(
  --             RogueEssence.Content.GraphicsManager.TileSize / 2,
  --             RogueEssence.Content.GraphicsManager.TileSize / 2
  --         )
  --         + RogueElements.Loc(-80, 52),

  --     Dir8.Left
  -- )


  --  DrawLayer.NoDraw
  -- print("AAAA")

  -- UI:WaitShowDialogue("A mystical energy radiates from the chest as it opens. Choose your enchantment")

  -- DungeonScene.Instance:CreateAnim(emitter, DrawLayer.NoDraw)

  -- emitter:SetupEmit(RogueElements.Loc(activator.MapLoc.X + -100, activator.MapLoc.Y + 100), RogueElements.Loc(activator.MapLoc.X - 200, activator.MapLoc.Y  + 100), Dir8.Up)
  --   GameManager.Instance.BattleSE("EVT_Fade_White");
  -- {
  --     SingleEmitter emitter = new SingleEmitter(new AnimData("Chest_Light", 4));
  --     emitter.SetupEmit(baseLoc * GraphicsManager.TileSize + new Loc(GraphicsManager.TileSize / 2) + new Loc(-100, 72), baseLoc * GraphicsManager.TileSize + new Loc(GraphicsManager.TileSize / 2) + new Loc(-80, 52), Dir8.Left);
  --     DungeonScene.Instance.CreateAnim(emitter, DrawLayer.NoDraw);
  -- }
  -- {
  --     SingleEmitter emitter = new SingleEmitter(new AnimData("Chest_Light", 4));
  --     emitter.SetupEmit(baseLoc * GraphicsManager.TileSize + new Loc(GraphicsManager.TileSize / 2) + new Loc(100, 72), baseLoc * GraphicsManager.TileSize + new Loc(GraphicsManager.TileSize / 2) + new Loc(80, 52), Dir8.Right);
  --     DungeonScene.Instance.CreateAnim(emitter, DrawLayer.NoDraw);
  -- }

  -- emitter.LocHeight = 12

  -- GAME:WaitFrames(60)
  -- UI:WaitShowDialogue("BOOM.")

  -- SOUND:PlayBattleSE("DUN_Explosion")
  -- emitter = RogueEssence.Content.FiniteAreaEmitter(RogueEssence.Content.AnimData("Explosion", 3))
  -- emitter.Range = 72
  -- emitter.Speed = 72
  -- emitter.TotalParticles = 12
  -- GROUND:PlayVFX(emitter, activator.MapLoc.X, activator.MapLoc.Y)
  -- GROUND:ObjectSetDefaultAnim(obj, 'Ches', 0, 0, 0, Direction.Right)	
  -- GROUND:ObjectSetAnim(obj, 6, 0, 3, Direction.Right, 1)
  -- GROUND:ObjectSetDefaultAnim(obj, 'Diary_Purple_Opening', 0, 3, 3, Direction.Right)
  -- CHEST:OpenChest(obj, activator)
end

-------------------------------
-- Entities Callbacks
-------------------------------

-- function frost_checkpoint.Teammate1_Action(chara, activator)
--   -- DEBUG.EnableDbgCoro() --Enable debugging this coroutine
--   -- PartnerEssentials.GetPartnerDialogue(CH('Teammate1'))
--  end

function frost_checkpoint.Teammate2_Action(chara, activator)
  -- DEBUG.EnableDbgCoro() --Enable debugging this coroutine
  -- if SV.ChapterProgression.Chapter == 5 then--growlithe dialogue
  -- searing_tunnel_midpoint_ch_5.Growlithe_Action(chara, activator)
  -- else
  -- GeneralFunctions.GroundInteract(activator, chara)
  -- end
end

function frost_checkpoint.Teammate1_Action(chara, activator)
  DEBUG.EnableDbgCoro() -- Enable debugging this coroutine
  COMMON.GroundInteract(activator, chara)
end

return frost_checkpoint
